在没有 FPU（浮点运算单元）的低端单片机（如传统的 8051 或某些 Cortex-M0 内核）上，直接操作浮点数会触发极其耗时的软件模拟库。

为了追求极致速度，我们通常使用**整数位移开方算法（Integer Binary Search Root）**。它的核心思想类似于“手动长除法开平方”，但利用了二进制的特性，只使用**移位（Shift）**、**减法（Sub）和逻辑与/或（And/Or）**。

---

## 1. 算法逻辑：逐位试探法

这种算法利用了一个数学性质：任何整数 $n$ 的平方根，都可以表示为二进制形式。例如，若结果是 8 位整数，我们就从最高位（$2^7$）开始向下试探。

**基本步骤：**

1. **假设**：从结果的最高有效位（MSB）开始，假设该位为 1。
    
2. **平方对比**：计算这个假设值的平方。
    
3. **判断与保留**：
    
    - 如果假设值的平方 $\le$ 目标值，说明这一位确实应该是 1，保留它。
        
    - 如果假设值的平方 $>$ 目标值，说明这一位应该是 0，舍弃它。
        
4. **循环**：移动到下一位，重复上述过程。
    

---

## 2. 优化后的位运算实现（C 语言）

为了避免在循环里做昂贵的“平方”运算，我们可以维护一个残差（Remainder）。以下是一个针对 32 位整数（返回 16 位开方结果）的标准工业级实现：

```c
uint16_t sqrt32(uint32_t n) {
    uint32_t root = 0;   // 最终结果
    uint32_t rem = 0;    // 余数
    uint32_t temp;       // 临时变量

    // 32位整数的开方结果最多16位，所以循环16次
    for (int i = 0; i < 16; i++) {
        // 每次循环左移两位：因为 (10x)^2 = 100 * x^2，结果进1位，原数进2位
        rem = (rem << 2) | (n >> 30);
        n <<= 2;
        
        root <<= 1; // 结果左移准备试探下一位
        
        temp = (root << 1) | 1; // 计算试探值：2*current_root + 1
        
        if (rem >= temp) {
            rem -= temp;
            root |= 1; // 证明这一位应该是1
        }
    }
    return (uint16_t)root;
}
```

---

## 3. 为什么这个算法在单片机上很快？

1. **没有乘法和除法**：所有的 `<<` 和 `>>` 都是单周期指令。
    
2. **确定性时间**：无论输入的值是多少，`for` 循环的次数是固定的（32 位输入就是 16 次），这对于实时性要求高的嵌入式系统非常友好。
    
3. **寄存器友好**：所有的变量都可以直接存储在 CPU 寄存器中，不需要访问慢速的 RAM。
    

---

## 4. 进一步优化的变体

如果你连 16 次循环都嫌慢，还有以下变体：

### A. 查表法 (Lookup Table)

如果输入范围很小（比如只有 0-255），直接做一个 `const uint8_t sqrt_table[]` 的数组，查表速度是 **O(1)**。

### B. 混合法

先用查表法得到一个大致的 8 位初始值，然后再进行 **1 次** 整数版的牛顿迭代。这种方法在高性能 DSP 处理中非常常见。

### C. 计算平方根倒数 (1/sqrt)

在处理信号处理（如传感器归一化）时，往往需要的是 $1/\sqrt{x}$。在单片机上，通常会使用基于二分法的位移算法来模拟，避免代价高昂的除法。

---
